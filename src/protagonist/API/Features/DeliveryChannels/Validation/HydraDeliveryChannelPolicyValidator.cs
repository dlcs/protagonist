using System.Text.RegularExpressions;
using DLCS.Model.Assets;
using FluentValidation;

namespace API.Features.DeliveryChannels.Validation;

/// <summary>
/// Validator for model sent to POST /deliveryChannelPolicies and PUT/PATCH /deliveryChannelPolicies/{id}
/// </summary>
public class HydraDeliveryChannelPolicyValidator : AbstractValidator<DLCS.HydraModel.DeliveryChannelPolicy>
{
    private readonly DeliveryChannelPolicyDataValidator policyDataValidator;
    
    private readonly string[] allowedDeliveryChannels =
    {
        AssetDeliveryChannels.Thumbnails,
        AssetDeliveryChannels.Timebased,
    };
    
    public HydraDeliveryChannelPolicyValidator(DeliveryChannelPolicyDataValidator policyDataValidator)
    {
        this.policyDataValidator = policyDataValidator;
        
        RuleFor(p => p.Id)
            .Empty()
            .WithMessage(p => $"DLCS must allocate named delivery channel policy id, but id {p.Id} was supplied");
        RuleFor(p => p.CustomerId)
            .Empty()
            .WithMessage("Should not include user id");
        RuleFor(p => p.Channel)
            .NotEmpty()
            .WithMessage("'channel' is required");
        RuleFor(p => p.Channel)
            .Must(IsPermittedDeliveryChannel!)
            .When(p => !string.IsNullOrEmpty(p.Channel))
            .WithMessage(p => $"'{p.Channel}' is not a valid/permitted delivery channel");
        RuleSet("post", () =>
        {
            RuleFor(p => p.Name)
                .NotEmpty()
                .WithMessage("'name' is required");
            RuleFor(p => p.Name)
                .Must(IsValidName!)
                .WithMessage("'name' is invalid");
            RuleFor(p => p.PolicyData)
                .NotEmpty()
                .WithMessage("'policyData' is required");
        });
        RuleSet("put", () =>
        {
            RuleFor(p => p.Name)
                .Must(IsValidName!)
                .WithMessage("'name' is invalid");
            RuleFor(p => p.PolicyData)
                .NotEmpty()
                .WithMessage("'policyData' is required");
        }); 
        RuleFor(p => p.PolicyData)
            .Must((p, pd) => IsValidPolicyData(pd, p.Channel))
            .When(p => !string.IsNullOrEmpty(p.PolicyData))
            .WithMessage(p => $"'policyData' contains bad JSON or invalid data");
        RuleFor(p => p.Modified)
            .Empty().WithMessage(c => $"'policyModified' is generated by the DLCS and cannot be set manually");
        RuleFor(p => p.Created)
            .Empty().WithMessage(c => $"'policyCreated' is generated by the DLCS and cannot be set manually");
    }
    
    private bool IsValidName(string inputName)
    {
        const string regex = "[\\sA-Z]"; // Delivery channel policy names should not contain capital letters or spaces
        if (string.IsNullOrEmpty(inputName)) return false;
        return !(Regex.IsMatch(inputName, regex));
    }
    
    private bool IsPermittedDeliveryChannel(string deliveryChannelPolicyName)
    {
        return allowedDeliveryChannels.Contains(deliveryChannelPolicyName);
    }

    private bool IsValidPolicyData(string? policyData, string? channel)
    {
        if (string.IsNullOrEmpty(policyData) || string.IsNullOrEmpty(channel)) return false;
        return policyDataValidator.Validate(policyData, channel);
    }
}